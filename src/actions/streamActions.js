import {
  CREATED_STREAM,
  FETCHING_FAILED_STREAMS,
  FETCHING_STREAMS,
  FETCHED_STREAMS,
  FETCHING_FAILED_STREAM,
  FETCHING_STREAM,
  FETCHED_STREAM,
} from "./actionTypes";

import database from "../configs/FirebaseConfig";

let createStream = ({ title, description }) => (dispatch, getState) => {
  let userId = getState().auth.user.id;
  let date = new Date();

  return database
    .collection("streams")
    .add({
      title,
      description,
      userId,
      date,
    })
    .then(() => {
      database
        .collection("streams")
        .where("userId", "==", userId)
        .orderBy("date", "desc")
        .limit(1)
        .get()
        .then((querySnapShot) => {
          // fetching the same stream because the unique key is generated by the database.
          let latestStreamData = querySnapShot.docs[0].data();
          let latestStreamId = querySnapShot.docs[0].id;
          let newCreatedStream = { latestStreamId, ...latestStreamData };

          dispatch({ type: CREATED_STREAM, payload: newCreatedStream });
        });
    });
};

let fetchStreams = () => (dispatch) => {
  dispatch({ type: FETCHING_STREAMS });

  database
    .collection("streams")
    .orderBy("date", "desc")
    .get()
    .then(
      (querySnapshot) => {
        let streamsArray = querySnapshot.docs.map((doc) => {
          let id = doc.id;
          return { id, ...doc.data() };
        });

        dispatch({ type: FETCHED_STREAMS, payload: streamsArray });
      },
      (err) => {
        dispatch({ type: FETCHING_FAILED_STREAMS, payload: err });
      }
    );
};

let fetchStream = (streamId = null) => (dispatch, getState) => {
  dispatch({ type: FETCHING_STREAM });

  let streamsData = getState.stream.streams.data;
  let requestedStream = streamsData.find((stream) => stream.id === streamId);

  if (requestedStream) {
    let streamUserId = requestedStream.userId;

    return database
      .collection("users")
      .where("id", "==", streamUserId)
      .get()
      .then((res) => {
        const streamUserProfile = res.docs[0].data();

        dispatch({
          type: FETCHED_STREAM,
          data: requestedStream,
          user: streamUserProfile,
        });
      });
  } else {
    dispatch({ type: FETCHING_FAILED_STREAM, payload: requestedStream });
  }
};

export { createStream, fetchStreams, fetchStream };
